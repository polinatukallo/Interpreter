# Variadic Templates
Шаблоном с переменным числом параметров (_variadic template_) называется шаблон функции или класса, принимающий так называемый _parameter pack_. При объявлении шаблона это выглядит следующим образом  
  

template<typename… Args> struct some_type;

  
Такая запись значит то, что шаблон может принять 0 или более типов в качестве своих аргументов. В теле же шаблона синтаксис использования немного другой.

Введен в 11ом стандарте

Параметры нельзя использовать просто так, перед использованием их надо развернуть(рекурсивно, с использованием инициализации или с С++17 fold expression).

# Parameter Pack
это набор типов или аргументов передаваемый в шаблон функции или класса с помощью троеточие
Есть два типа: типовой параметр пакет typename... Args
Значенческий параметр пакет: int... auto...
Через sizeof доступен подсчет числа параметров
- можно делать наследование по каждому типу

# Fold-expression
это способ "свернуть" параметр пакет в единую операцию, используя бинарный оператор. удобная альтернатива ручной рекурсии при работе с variadic templates.

Свертка – это функция, которая применяет заданную комбинирующую функцию к последовательным парам элементов в списке и возвращает результат.

Если комбинирующая функция применяется к первому элементу списка и результату рекурсивной обработки хвоста списка, то свертка называется **правоассоциативной. В нашем примере получим:  
  

```
1 + (3 + (5 + (7 + 0)))
```

  
Если комбинирующая функция применяется к результату рекурсивной обработки начала списка _(весь список без последнего элемента)_ и последнему элементу, то свертка называется **левоассоциативной. В нашем примере получим:  
  

(((0 + 1) + 3) + 5) + 7

В C++17 появилась поддержка свертки для списка параметров шаблонов. Она имеет следующий синтаксис:  

|                    |                                     |
| ------------------ | ----------------------------------- |
| (pack op ...)      | Унарная правоассоциативная свертка  |
| (… op pack)        | Унарная левоассоциативная свертка   |
| (pack op… op init) | Бинарная правоассоциативная свертка |
| (init op… op pack) | Бинарная левоассоциативная свертка  |
_op_ – один из следующих бинарных операторов:  
  

+ - * / % ^ & | ~ = < > << >> += -= *= /= %=^= &= |= <<= >>= == != <= >= && || , .* ->*

  
_pack_ – выражение, содержащее нераскрытую группу параметров (parameter pack)  
  
_init_ – начальное значение

# Overload Pattern
Overload Pattern (паттерн перегрузки) — это идиома в C++, которая позволяет создавать перегруженные функциональные объекты (функторы), комбинируя несколько отдельных функций или лямбда-выражений в один вызываемый объект.

Цель:
1. Упрощение кода** при работе с различными типами в шаблонах
2. **Объединение нескольких операторов вызова** в один функциональный объект
3. **Создание мульти-функторов** — объектов, которые ведут себя по-разному для разных типов
До С++17 приходилось использовать наследования и using декларации

Как работает:
```cpp
std::variant<int, float, std::string> v = "hello";

auto visitor = overload{
    [](int i) { std::cout << "int: " << i; },
    [](float f) { std::cout << "float: " << f; },
    [](const std::string& s) { std::cout << "string: " << s; }
};

std::visit(visitor, v); // Выведет: string: hello
```

## Как это работает (подробно)

1. **Наследование от лямбд: Структура `overload` наследуется от всех переданных лямбда-выражений
    
2. Using-декларация: `using Ts::operator()...` "поднимает" все операторы вызова из базовых классов
    
3. Дедукционное руководство: Позволяет создавать объекты `overload` без явного указания шаблонных параметров


CTAD — это механизм, введённый в C++17, который позволяет компилятору автоматически выводить аргументы шаблона класса на основе аргументов конструктора.

# std::visit + std::variant
Вместе они образуют мощный механизм для **типобезопасной обработки альтернативных типов**, альтернативный традиционным подходам с полиморфизмом или `union`.


## Что означает это сочетание
1. `std::variant`** - хранит один из нескольких возможных типов
    
2. std::visit - применяет посетитель (visitor) к содержимому variant
    

Вместе они образуют мощный механизм для **типобезопасной обработки альтернативных типов, альтернативный традиционным подходам с полиморфизмом или `union`.

## Ключевые преимущества связки

1. Типобезопасность** - компилятор проверяет все типы
    
2. **Нулевые накладные расходы** - нет виртуальных функций
    
3. **Расширяемость** - легко добавить новые типы
    
4. **Чистый код** - явная обработка всех случаев

## Особенности работы

1. `std::visit` автоматически выбирает правильную перегрузку
    
2. Посетитель должен обрабатывать все типы variant
    
3. Можно использовать с несколькими variant одновременно
    
4. Работает с любыми вызываемыми объектами (функции, лямбды, функторы)

Да, `std::variant` работает с **информацией о типах на этапе компиляции, но само значение хранится и обрабатывается во время выполнения.

# Метафункции в стандартной библиотеке
Type traits
Проверки типов:
`std::is_integral<T>::value       // true для целочисленных типов`
`std::is_floating_point<T>::value  // true для float/double`
`std::is_pointer<T>::value         // true для указателей`
`std::is_reference<T>::value       // true для ссылок`
Модификации типов
Модификации типов:
`std::remove_const<T>::type        // Удаляет const`
`std::add_pointer<T>::type        // Добавляет *`
`std::decay<T>::type              // Аналог передачи по значению`
`std::remove_reference<T>::type   // Удаляет &`



`std::integral_constant - базовый строительный блок`

Служит базой для всех type traits
- using five_type = std::integral_constant<int, 5>;
constexpr int val = five_type::value; // 5
    
- Позволяет использовать тип как значение
    
- Поддерживает вызов как функциональный объект
|Создание собственных проверок типов|Наследуют от integral_constant|

std::true_type и std::false_type
 std::conditional - выбор типа по условию
 - Аналог тернарного оператора для типов
 std::enable_if - условное включение кода
 1. Если условие `B` истинно - определяет вложенный тип `type`
    
2. Если ложно - остается пустым (вызывает SFINAE-отбрасывание)
std::tuple_element - доступ к элементам кортежа
std::variant_size - проверка размера варианта
std::declval - объявление значения без конструктора
Позволяет "притвориться", что у нас есть объект типа T, даже если у T нет конструктора по умолчанию.
std::common_type - общий тип для нескольких типов

# SFINAE
 _substitution failure is not an error_
  при определении перегрузок функции ошибочные инстанциации шаблонов не вызывают ошибку компиляции, а отбрасываются из списка кандидатов на наиболее подходящую перегрузку.
- Когда речь заходит о SFINAE, это обязательно связано с перегрузкой функций.
- Это работает при автоматическом выводе типов шаблона (type deduction) по аргументам функции.
- Некоторые перегрузки могут отбрасываться в том случае, когда их невозможно инстанциировать из-за возникающей синтаксической ошибки; компиляция при этом продолжается как ни в чём не бывало, без ошибок.
- Отбросить могут только шаблон.
- SFINAE рассматривает только заголовок функции, ошибки в теле функции не будут пропущены.
1. Он подставляет типы/значения в шаблон
    
2. Если подстановка приводит к некорректному коду — это не вызывает ошибку
    
3. Компилятор просто исключает эту перегрузку из consideration (рассмотрения)
    
4. Продолжает поиск других подходящих перегрузок
Как по факту работает
5. Подстановка (Substitution):
    
    - Компилятор подставляет фактические типы в шаблон
        
    - Проверяет, получается ли корректный код
        
6. Отбрасывание (Failure):
    
    - Если подстановка приводит к некорректному коду:
        
        - Некорректный тип (например, void в нетипизированном контексте)
            
        - Некорректное выражение (например, вызов несуществующего метода)
            
    - Эта перегрузка молча игнорируется
        
7. Продолжение поиска:
    
    - Компилятор продолжает искать другие подходящие перегрузки
        
    - Если ни одна не подходит — тогда выдает ошибку
    # Концепты
    Концепт фактически представляет шаблон для именованного набора ограничений, где каждое ограничение предписывает одно или несколько требований для одного или нескольких параметров шаблона. В общем случае он имеет следующий вид
        `template` `<параметры>`

`concept имя_концепта = ограничения;`
Список параметров концепта содержит один или несколько параметров шаблона. Во время компиляции компилятор оценивает концепты, чтобы определить, удовлетворяет ли набор аргументов заданным ограничениям.

`Ограничения` представляют условные выражения, которые возвращают значение типа bool - если параметр типа удовлетворяет условию, то возвращается true.

Теперь главный вопрос - зачем все эти концепты нужны? Мы можем применять концепты в качестве ограничений для шаблонов:
`#include <iostream>`

`template` `<``typename` `T>`

`concept size =` `sizeof``(T) <=` `sizeof``(``int``);`

`template` `<``typename` `T> requires size<T>` `// в качестве ограничения применяется size`

`T sum(T a, T b){` `return` `a + b;}`

`int` `main()`

`{`

    `std::cout << sum(10, 3) << std::endl;`       `// 13`

    `//std::cout << sum(10.6, 3.7) << std::endl; // ! Ошибка`

`}`
В данном случае определен концепт size, согласно которому размер типа T должен быть равен или меньше размера типа int.
### Сокращенный синтаксис

С++ позволяет сократить синтаксис применения концепта:

|   |   |
|---|---|
|1<br><br>2|template <size T> // в качестве ограничения применяется size<br><br>T sum(T a, T b){ return a + b;}|

В таком случае концепт указывается в угловых скобках вместо слова `typename` перед названием параметра типа